name: Import Stabilization Backlog

on:
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  projects: write

jobs:
  import:
    runs-on: ubuntu-latest
    env:
      PROJECT_ID: ${{ secrets.PROJECT_ID }}
      PROJECT_NUMBER: ${{ secrets.PROJECT_NUMBER }}
      PARENT_FIELD_ID: ${{ secrets.PARENT_FIELD_ID }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Debug workspace layout
        run: |
          ls -R .
          ls -R automation

      - name: Import issues and sync project
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const projectId = process.env.PROJECT_ID;
            const projectNumber = process.env.PROJECT_NUMBER;
            const parentFieldId = process.env.PARENT_FIELD_ID;

            if (!projectId || !projectNumber || !parentFieldId) {
              core.setFailed('PROJECT_ID, PROJECT_NUMBER, and PARENT_FIELD_ID must be provided through secrets or environment variables.');
              return;
            }

            core.info(`Targeting project ${projectNumber} (${projectId}).`);

            const issuesPath = path.join(process.cwd(), 'automation', 'issues.json');
            const issues = JSON.parse(fs.readFileSync(issuesPath, 'utf8'));
            const epicMap = new Map();
            const { owner, repo } = context.repo;

            async function searchIssueByTitle(title) {
              const query = `repo:${owner}/${repo} in:title "${title}" type:issue`;
              const search = await github.rest.search.issuesAndPullRequests({ q: query, per_page: 5 });
              return search.data.items.find(item => item.title === title && !item.pull_request) || null;
            }

            async function ensureIssue(issue) {
              const existing = await searchIssueByTitle(issue.title);
              if (existing) {
                core.info(`Found existing issue #${existing.number} for ${issue.title}.`);
                return existing;
              }

              const created = await github.rest.issues.create({
                owner,
                repo,
                title: issue.title,
                body: issue.body,
                labels: issue.labels
              });

              core.info(`Created issue #${created.data.number} for ${issue.title}.`);
              return created.data;
            }

            async function fetchProjectItemId(issueNodeId) {
              const query = await github.graphql(
                `query($nodeId: ID!) {
                  node(id: $nodeId) {
                    ... on Issue {
                      projectItems(first: 20) {
                        nodes {
                          id
                          project { id }
                        }
                      }
                    }
                  }
                }`,
                { nodeId: issueNodeId }
              );

              const nodes = query?.node?.projectItems?.nodes || [];
              const existing = nodes.find(node => node.project.id === projectId);
              if (existing) {
                core.info(`Issue already linked to project: ${existing.id}`);
                return existing.id;
              }

              const added = await github.graphql(
                `mutation($projectId: ID!, $contentId: ID!) {
                  addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
                    item { id }
                  }
                }`,
                { projectId, contentId: issueNodeId }
              );

              const itemId = added.addProjectV2ItemById.item.id;
              core.info(`Added project item ${itemId}.`);
              return itemId;
            }

            async function linkToParent(itemId, parentItemId) {
              await github.graphql(
                `mutation($projectId: ID!, $fieldId: ID!, $itemId: ID!, $parentId: ID!) {
                  updateProjectV2ItemFieldValue(
                    input: {
                      projectId: $projectId,
                      fieldId: $fieldId,
                      itemId: $itemId,
                      value: { projectV2ItemId: $parentId }
                    }
                  ) {
                    projectV2Item { id }
                  }
                }`,
                {
                  projectId,
                  fieldId: parentFieldId,
                  itemId,
                  parentId: parentItemId
                }
              );

              core.info(`Linked ${itemId} to parent ${parentItemId}.`);
            }

            for (const issue of issues) {
              const record = await ensureIssue(issue);
              const issueNodeId = record.node_id;
              const projectItemId = await fetchProjectItemId(issueNodeId);

              if (!issue.epic) {
                epicMap.set(issue.id, { projectItemId });
                continue;
              }

              const parent = epicMap.get(issue.epic);
              if (!parent) {
                throw new Error(`Parent epic with id ${issue.epic} not processed before child ${issue.title}.`);
              }

              await linkToParent(projectItemId, parent.projectItemId);
            }

            core.info('Backlog import completed successfully.');
