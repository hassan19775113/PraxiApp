# Generated by GitHub Copilot (GPT-5.2) on 2026-01-27

from __future__ import annotations

from datetime import date

import django.db.models.deletion
from django.db import migrations, models


def _table_names(schema_editor) -> set[str]:
    return set(schema_editor.connection.introspection.table_names())


def _rename_table(schema_editor, *, old: str, new: str) -> None:
    """Rename a table if the backend supports it.

    We keep this tiny and backend-aware because SQLite and Postgres differ in
    quoting behavior.
    """
    conn = schema_editor.connection
    vendor = conn.vendor

    if vendor in {"sqlite", "postgresql"}:
        with conn.cursor() as cursor:
            cursor.execute(f'ALTER TABLE "{old}" RENAME TO "{new}";')
        return

    raise RuntimeError(f"Unsupported DB backend for table rename: {vendor}")


def forwards_prepare_tables(apps, schema_editor):
    """Prepare tables before we (re)create the managed `patients` table.

    - DEV SQLite historically used a legacy table named `patients`.
      We rename it to `legacy_patients` to avoid name collision.
    - We rename the former cache table `patients_cache` to
      `patients_cache_backup` so we can copy data and then drop it.
    """
    tables = _table_names(schema_editor)

    # If a `patients` table already exists, we keep it *if* it looks like the
    # expected unified schema. Otherwise we rename it out of the way.
    if "patients" in tables and "legacy_patients" not in tables:
        conn = schema_editor.connection
        vendor = conn.vendor
        cols: set[str] = set()

        try:
            with conn.cursor() as cursor:
                if vendor == "sqlite":
                    cols = {
                        row[1]
                        for row in cursor.execute('PRAGMA table_info("patients");').fetchall()
                    }
                else:
                    cols = {
                        c.name for c in conn.introspection.get_table_description(cursor, "patients")
                    }
        except Exception:
            cols = set()

        expected = {"id", "first_name", "last_name", "birth_date"}
        if not expected.issubset(cols):
            _rename_table(schema_editor, old="patients", new="legacy_patients")

    tables = _table_names(schema_editor)

    # Preserve cache data for migration, then drop later.
    if "patients_cache" in tables and "patients_cache_backup" not in tables:
        _rename_table(schema_editor, old="patients_cache", new="patients_cache_backup")


def forwards_copy_cache_into_patients(apps, schema_editor):
    """Copy cached patient rows into the new managed patients table.

    This keeps as much data as possible during the architecture switch.
    The new Patient primary key equals the old cache `patient_id`.

    If no cache backup exists, this is a no-op.
    """
    conn = schema_editor.connection
    vendor = conn.vendor
    tables = _table_names(schema_editor)

    if "patients_cache_backup" not in tables:
        return

    if vendor == "sqlite":
        sql = """
        INSERT OR IGNORE INTO patients (
            id, first_name, last_name, birth_date, gender, phone, email, created_at, updated_at
        )
        SELECT
            patient_id,
            first_name,
            last_name,
            birth_date,
            NULL,
            NULL,
            NULL,
            created_at,
            updated_at
        FROM patients_cache_backup
        WHERE patient_id IS NOT NULL AND patient_id > 0;
        """.strip()
    elif vendor == "postgresql":
        sql = """
        INSERT INTO patients (
            id, first_name, last_name, birth_date, gender, phone, email, created_at, updated_at
        )
        SELECT
            patient_id,
            first_name,
            last_name,
            birth_date,
            NULL,
            NULL,
            NULL,
            created_at,
            updated_at
        FROM patients_cache_backup
        WHERE patient_id IS NOT NULL AND patient_id > 0
        ON CONFLICT (id) DO NOTHING;
        """.strip()
    else:
        raise RuntimeError(f"Unsupported DB backend for cache copy: {vendor}")

    with conn.cursor() as cursor:
        cursor.execute(sql)


def forwards_create_patients_table_if_missing(apps, schema_editor):
    """Create `patients` table if it does not exist.

    Some environments (DEV SQLite) may already have a `patients` table with the
    correct schema (e.g. after previous import steps). In those cases we must
    not recreate it.
    """
    tables = _table_names(schema_editor)
    if "patients" in tables:
        return

    Patient = apps.get_model("patients", "Patient")
    schema_editor.create_model(Patient)


def forwards_ensure_patients_for_references(apps, schema_editor):
    """Ensure every referenced patient_id exists in the managed patients table.

    We add placeholder rows so that FK constraints on patient_notes / patient_documents
    can be enabled safely on both SQLite and PostgreSQL.

    The management command `migrate_patients_from_legacy` should be run afterwards
    to replace placeholders with real master data.
    """
    alias = schema_editor.connection.alias

    Patient = apps.get_model("patients", "Patient")
    PatientNote = apps.get_model("patients", "PatientNote")
    PatientDocument = apps.get_model("patients", "PatientDocument")
    Appointment = apps.get_model("appointments", "Appointment")
    Operation = apps.get_model("appointments", "Operation")

    referenced_ids: set[int] = set()

    def _collect(qs):
        for pid in qs:
            if pid is None:
                continue
            try:
                pid = int(pid)
            except (TypeError, ValueError):
                continue
            if pid > 0:
                referenced_ids.add(pid)

    _collect(PatientNote.objects.using(alias).values_list("patient_id", flat=True).distinct())
    _collect(PatientDocument.objects.using(alias).values_list("patient_id", flat=True).distinct())
    _collect(Appointment.objects.using(alias).values_list("patient_id", flat=True).distinct())
    _collect(Operation.objects.using(alias).values_list("patient_id", flat=True).distinct())

    if not referenced_ids:
        return

    existing = set(
        Patient.objects.using(alias).filter(id__in=referenced_ids).values_list("id", flat=True)
    )
    missing = sorted(referenced_ids - existing)
    if not missing:
        return

    placeholders = [
        Patient(
            id=pid,
            first_name="Unknown",
            last_name="Unknown",
            birth_date=date(1900, 1, 1),
        )
        for pid in missing
    ]
    Patient.objects.using(alias).bulk_create(placeholders, ignore_conflicts=True)


class Migration(migrations.Migration):

    dependencies = [
        ("appointments", "0013_doctorhours_uniq_doctorhours_slot_active"),
        ("patients", "0005_patientnote_author_role"),
    ]

    operations = [
        migrations.RunPython(forwards_prepare_tables, reverse_code=migrations.RunPython.noop),
        # Replace the former cache-based Patient model with a single, managed master model.
        migrations.SeparateDatabaseAndState(
            database_operations=[],
            state_operations=[
                migrations.DeleteModel(name="Patient"),
                migrations.CreateModel(
                    name="Patient",
                    fields=[
                        ("id", models.IntegerField(primary_key=True, serialize=False)),
                        ("first_name", models.CharField(blank=True, default="", max_length=100)),
                        ("last_name", models.CharField(blank=True, default="", max_length=100)),
                        ("birth_date", models.DateField(blank=True, null=True)),
                        ("gender", models.CharField(blank=True, max_length=20, null=True)),
                        ("phone", models.CharField(blank=True, max_length=50, null=True)),
                        ("email", models.CharField(blank=True, max_length=255, null=True)),
                        ("created_at", models.DateTimeField(blank=True, null=True)),
                        ("updated_at", models.DateTimeField(blank=True, null=True)),
                    ],
                    options={
                        "db_table": "patients",
                        "ordering": ["last_name", "first_name", "id"],
                        "verbose_name": "Patient",
                        "verbose_name_plural": "Patients",
                    },
                ),
            ],
        ),
        migrations.RunPython(
            forwards_create_patients_table_if_missing,
            reverse_code=migrations.RunPython.noop,
        ),
        migrations.RunPython(
            forwards_copy_cache_into_patients,
            reverse_code=migrations.RunPython.noop,
        ),
        migrations.RunPython(
            forwards_ensure_patients_for_references,
            reverse_code=migrations.RunPython.noop,
        ),
        # Drop the old cache table after copying (if it existed).
        migrations.RunSQL(
            sql="DROP TABLE IF EXISTS patients_cache_backup;",
            reverse_sql=migrations.RunSQL.noop,
        ),
        # Rename patient_id fields to patient (state-only) while keeping the same DB column.
        # IMPORTANT: Set db_column explicitly *before* the rename so Django doesn't assume
        # an implicit column name change (patient_id -> patient) during the later FK AlterField.
        migrations.SeparateDatabaseAndState(
            database_operations=[],
            state_operations=[
                migrations.AlterField(
                    model_name="patientdocument",
                    name="patient_id",
                    field=models.IntegerField(db_column="patient_id", db_index=True),
                ),
                migrations.RenameField(
                    model_name="patientdocument",
                    old_name="patient_id",
                    new_name="patient",
                ),
                migrations.AlterField(
                    model_name="patientnote",
                    name="patient_id",
                    field=models.IntegerField(db_column="patient_id", db_index=True),
                ),
                migrations.RenameField(
                    model_name="patientnote",
                    old_name="patient_id",
                    new_name="patient",
                ),
            ],
        ),
        migrations.AlterField(
            model_name="patientdocument",
            name="patient",
            field=models.ForeignKey(
                db_column="patient_id",
                on_delete=django.db.models.deletion.CASCADE,
                related_name="documents",
                to="patients.patient",
            ),
        ),
        migrations.AlterField(
            model_name="patientnote",
            name="patient",
            field=models.ForeignKey(
                db_column="patient_id",
                on_delete=django.db.models.deletion.CASCADE,
                related_name="notes",
                to="patients.patient",
            ),
        ),
    ]
